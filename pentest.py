#!/usr/bin/env python3
import os
import re
from datetime import datetime
import shutil
import ipaddress
from getpass import getuser

DOCS_DIR = "docs"
LOGS_DIR = "logs"

if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)

def lister_couches():
    couches = []
    for d in os.listdir(DOCS_DIR):
        couche_path = os.path.join(DOCS_DIR, d)
        if os.path.isdir(couche_path):
            for file in os.listdir(couche_path):
                if file.startswith('cheat-couche_') and file.endswith('.md'):
                    couches.append((d, os.path.join(couche_path, file)))
    couches = sorted(couches, key=lambda x: x[0])
    return couches

def extraire_types_attaques(filepath):
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    pattern = r"## 1\. Types d'attaques.*?\n((?:- .+\n)+)"
    match = re.search(pattern, contenu, re.DOTALL)
    attaques = []
    if match:
        bloc = match.group(1)
        for line in bloc.split('\n'):
            if line.startswith('- '):
                if '  :' in line:
                    titre, explication = line[2:].split('  :', 1)
                    attaques.append((titre.strip(), explication.strip()))
                elif ':' in line:
                    titre, explication = line[2:].split(':', 1)
                    attaques.append((titre.strip(), explication.strip()))
                else:
                    attaques.append((line[2:].strip(), ""))
    return attaques

def extraire_bloc_attaque(filepath, attaque_nom):
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    attaque_pattern = re.compile(
        r"###\s*⚡\s*Attaque\s*:\s*([^\n]+)\n(.*?)(?=^### |^## |\Z)", re.DOTALL | re.MULTILINE | re.IGNORECASE)
    for match in attaque_pattern.finditer(contenu):
        titre = match.group(1).strip().lower()
        if titre == attaque_nom.strip().lower():
            return match.group(2)
    return ""

def extraire_outils_du_bloc(bloc):
    outils = []
    outil_pattern = re.compile(
        r"####\s*Outil\s*:\s*([^\n]+)\n"
        r"\*\*Description\*\*\s*:\s*(.+?)\n"
        r"\*\*Installation\*\*\s*:\s*(.+?)(?=\n\*\*Commande\*\*|\n\*\*Info\*\*|\n\*\*Note\*\*|\n#### Outil|$)",
        re.DOTALL | re.MULTILINE
    )
    for outil_match in outil_pattern.finditer(bloc):
        nom = outil_match.group(1).strip()
        description = outil_match.group(2).strip().replace('\n', ' ')
        installation = outil_match.group(3).strip()
        commandes = []
        infos = []
        outil_bloc_start = outil_match.end()
        outil_bloc_end = bloc.find('#### Outil', outil_bloc_start)
        outil_bloc = bloc[outil_bloc_start:outil_bloc_end if outil_bloc_end != -1 else None]
        for cmd_match in re.finditer(r"\*\*Commande\*\*\s*:\s*(.+)", outil_bloc or ''):
            cmd = cmd_match.group(1).strip()
            commandes.append(cmd)
        for info_match in re.finditer(r"\*\*(Info|Note)\*\*\s*:\s*(.+)", outil_bloc or ''):
            infos.append(info_match.group(2).strip())
        if not commandes:
            commandes = ["(Aucune commande shell définie pour cet outil)"]
        outils.append({
            "nom": nom,
            "description": description,
            "installation": installation,
            "commandes": commandes,
            "infos": infos
        })
    return outils

def is_ip_param(param):
    return 'ip' in param.lower()

def parametrize_command(cmd):
    params = re.findall(r"\[([^\]|]+)(?:\|([^\]]+))?\]", cmd)
    values = {}
    for param, default in params:
        prompt = f"Entrez la valeur pour '{param.strip()}'"
        if default:
            prompt += f" (Entrée pour '{default.strip()}')"
        prompt += " : "
        while True:
            value = input(prompt).strip()
            if not value and default:
                value = default.strip()
            if is_ip_param(param) and value:
                try:
                    ipaddress.ip_address(value)
                    break
                except Exception:
                    print("⛔ Valeur invalide, merci d’entrer une IP valide.")
            else:
                break
        values[param] = value
    for k, v in values.items():
        cmd = re.sub(rf"\[{re.escape(k)}(\|[^\]]+)?\]", v, cmd)
    return cmd, values

def outil_installe(nom):
    return shutil.which(nom.split()[0]) is not None

def choisir_dans_menu(items, titre="Faites un choix :", peut_annuler=True):
    while True:
        print("\n" + titre)
        for idx, item in enumerate(items, 1):
            print(f"{idx}. {item}")
        if peut_annuler:
            print("q. Annuler/Retour")
        choix = input("Votre choix : ")
        if peut_annuler and choix.lower() == 'q':
            return None
        try:
            choix_idx = int(choix) - 1
            if 0 <= choix_idx < len(items):
                return choix_idx
        except ValueError:
            pass
        print("Choix invalide.")

def installer_outil(cmd, nom):
    import subprocess
    try:
        subprocess.run(cmd, shell=True, check=True)
        if outil_installe(nom):
            print(f"[OK] '{nom}' installé avec succès.")
            return True
        else:
            print(f"[!] Installation terminée, mais l'outil n'est toujours pas détecté.")
            return False
    except Exception as e:
        print(f"Erreur lors de l'installation : {e}")
        return False

def saisir_info(label, default=None):
    prompt = f"{label}"
    if default:
        prompt += f" (Entrée pour '{default}')"
    prompt += " : "
    val = input(prompt)
    if not val and default:
        return default
    return val

def choisir_mode_execution():
    print("\nMode d'exécution ?")
    print("  1. Attendre la fin de la commande (résultat logué dans le rapport)")
    print("  2. Ouvrir la commande dans un terminal séparé (xterm, gnome-terminal...)")
    print("  3. Exécuter la commande en arrière-plan (pas de résultat logué)")
    mode = input("Votre choix [Entrée pour 1] : ").strip()
    if not mode:
        mode = '1'
    return mode

def main():
    print("==== Pentest Toolkit (Rapport Pro) ====\n")

    # ---- Saisie des infos générales du test ----
    test_info = {}
    test_info["date"] = datetime.now().strftime("%d/%m/%Y")
    test_info["testeur"] = saisir_info("Nom du testeur", getuser())
    test_info["client"] = saisir_info("Nom du client", "N/A")
    test_info["bien"] = saisir_info("Bien essentiel testé", "N/A")
    test_info["risque"] = saisir_info("Risque associé", "N/A")
    rapport_entries = []

    while True:
        couches = lister_couches()
        couche_idx = choisir_dans_menu([c[0] for c in couches], "Choisissez la couche à explorer :")
        if couche_idx is None:
            print("Fin du test ou abandon.")
            break
        couche_nom, couche_file = couches[couche_idx]

        attaques = extraire_types_attaques(couche_file)
        if not attaques:
            print("Aucune attaque trouvée dans ce fichier.")
            continue
        attaque_idx = choisir_dans_menu([f"{a[0]}  →  {a[1]}" for a in attaques], f"-- Types d'attaques disponibles pour {couche_nom} --")
        if attaque_idx is None:
            continue
        attaque_nom = attaques[attaque_idx][0]

        bloc_attaque = extraire_bloc_attaque(couche_file, attaque_nom)
        outils = extraire_outils_du_bloc(bloc_attaque)
        if not outils:
            print("Aucun outil trouvé pour cette attaque.")
            continue

        outil_idx = choisir_dans_menu([f"{o['nom']} : {o['description']}" for o in outils], f"-- Outils disponibles pour '{attaque_nom}' --")
        if outil_idx is None:
            continue
        outil_sel = outils[outil_idx]

        # Vérifie installation et propose l'installation automatique
        outil_name_cli = outil_sel['nom'].split()[0].lower()
        if not outil_installe(outil_name_cli):
            print(f"\n[INFO] L’outil '{outil_sel['nom']}' n'est pas détecté sur le système.")
            print(f"Commande d'installation proposée :\n{outil_sel['installation']}")
            doit_installer = input("Souhaites-tu installer cet outil maintenant ? [o/n] : ")
            if doit_installer.lower() == 'o':
                success = installer_outil(outil_sel['installation'], outil_name_cli)
                if not success:
                    while True:
                        print("Veux-tu réessayer, continuer sans installer, ou abandonner ? (r/c/q)")
                        choix = input("Ton choix : ")
                        if choix.lower() == 'r':
                            success = installer_outil(outil_sel['installation'], outil_name_cli)
                            if success:
                                break
                        elif choix.lower() == 'q':
                            print("Abandon de l'attaque en cours.")
                            break
                        elif choix.lower() == 'c':
                            print("Tu as choisi de continuer sans installer l'outil.")
                            break
                        else:
                            print("Choix invalide.")
            else:
                print("Installation annulée. Tu peux l'installer manuellement si besoin.")
                continue
        else:
            print(f"\n[INFO] L’outil '{outil_sel['nom']}' est installé.")

        # Multi-commandes support
        while True:
            cmd_idx = choisir_dans_menu(outil_sel['commandes'], "Commandes disponibles pour cette attaque :", False)
            if cmd_idx is None:
                print("Retour au choix de l'outil.")
                break
            cmd_original = outil_sel['commandes'][cmd_idx]
            cmd_ready, cmd_params = parametrize_command(cmd_original)
            print("\nCommande finale à exécuter :")
            print(cmd_ready)

            exec_mode = choisir_mode_execution()
            sortie = ""
            if exec_mode == '1':
                import subprocess
                print("Exécution (attente du résultat)...")
                try:
                    result = subprocess.run(cmd_ready, shell=True, capture_output=True, text=True)
                    sortie = result.stdout + result.stderr
                except Exception as e:
                    sortie = str(e)
                    print("Erreur d'exécution :", e)
                print(f"\nRésultat de la commande :\n{sortie}")
            elif exec_mode == '2':
                try:
                    term_cmd = (
                        f'x-terminal-emulator -e "{cmd_ready}"'
                        if shutil.which('x-terminal-emulator')
                        else f'xterm -e "{cmd_ready}"'
                        if shutil.which('xterm')
                        else f'gnome-terminal -- bash -c "{cmd_ready}; exec bash"'
                    )
                    print("Ouverture dans un nouveau terminal...")
                    os.system(term_cmd)
                    sortie = "(Commande lancée dans un terminal séparé.)"
                except Exception as e:
                    sortie = str(e)
                    print("Erreur lors de l'ouverture du terminal :", e)
            elif exec_mode == '3':
                try:
                    os.system(f"{cmd_ready} &")
                    sortie = "(Commande lancée en arrière-plan.)"
                except Exception as e:
                    sortie = str(e)
                    print("Erreur en arrière-plan :", e)
            else:
                print("Aucune commande exécutée.")
                sortie = "(Aucune commande exécutée.)"

            # Log dans la liste d'entrées pour le rapport final
            rapport_entries.append({
                "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "couche": couche_nom,
                "attaque": attaque_nom,
                "outil": outil_sel['nom'],
                "commande": cmd_ready,
                "cmd_params": cmd_params,
                "resultat": sortie
            })
            if outil_sel.get('infos'):
                print("\nInfos complémentaires :")
                for info in outil_sel['infos']:
                    print(f"- {info}")
            break

        continuer = input("\nEffectuer une nouvelle attaque/test ? [o/n] : ")
        if continuer.lower() != 'o':
            break

    # ---- Génération du rapport final ----
    print("\n--- Fin du test ---")
    commentaire = input("Commentaires à ajouter au rapport ? : ")
    conclusion = input("Conclusion ? : ")

    rapport_path = os.path.join(LOGS_DIR, f"rapport_pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md")
    with open(rapport_path, "w", encoding="utf-8") as f:
        f.write(f"# Rapport de Test de Sécurité\n")
        f.write(f"## Informations Générales\n")
        f.write(f"- **Date du test** : {test_info['date']}\n")
        f.write(f"- **Testeur** : {test_info['testeur']}\n")
        f.write(f"- **Client** : {test_info['client']}\n")
        f.write(f"---\n")
        f.write(f"## Bien Essentiel Testé\n")
        f.write(f"- **Bien essentiel** : {test_info['bien']}\n")
        f.write(f"- **Risque associé** : {test_info['risque']}\n")
        f.write(f"---\n")
        for i, entry in enumerate(rapport_entries, 1):
            f.write(f"## Attaque réalisée {i} : {entry['attaque']}\n")
            f.write(f"- **Outil utilisé** : {entry['outil']}\n")
            f.write(f"- **Commande exécutée** : `{entry['commande']}`\n")
            if entry['cmd_params']:
                f.write(f"- **Paramètres** : {entry['cmd_params']}\n")
            f.write(f"### Résultats du Test\n")
            f.write("```\n")
            f.write(entry['resultat'] or "Aucun résultat ou erreur d'exécution.\n")
            f.write("```\n---\n")
        f.write(f"## Commentaires\n{commentaire}\n---\n")
        f.write(f"## Conclusion\n{conclusion}\n")

    print(f"\n[OK] Rapport généré : {rapport_path}\n")

if __name__ == "__main__":
    main()
