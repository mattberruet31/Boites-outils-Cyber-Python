import os
import re
from datetime import datetime

DOCS_DIR = "docs"
LOGS_DIR = "logs"
REPORT_FILE = f"rapport_pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"

if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)

def lister_couches():
    couches = []
    for d in os.listdir(DOCS_DIR):
        couche_path = os.path.join(DOCS_DIR, d)
        if os.path.isdir(couche_path):
            for file in os.listdir(couche_path):
                if file.startswith('cheat-couche_') and file.endswith('.md'):
                    couches.append((d, os.path.join(couche_path, file)))
    return couches

def lire_types_attaques(filepath):
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    pattern = r"## 1\. Types d'attaques?.+?\n((?:- .+\n)+)"
    match = re.search(pattern, contenu, re.DOTALL)
    if not match:
        return []
    attaques_brutes = match.group(1).strip().split("\n")
    attaques = [a.strip("- ").strip() for a in attaques_brutes if a.strip()]
    return attaques

def lister_attaques_avec_explications(filepath):
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    pattern = r"## 1\. Types d'attaques?.+?\n((?:- .+\n)+)"
    match = re.search(pattern, contenu, re.DOTALL)
    if not match:
        return []
    attaques_brutes = match.group(1).strip().split("\n")
    result = []
    for a in attaques_brutes:
        if "—" in a or "-" in a:
            # Sépare titre et explication
            parts = a.strip("- ").split("  ", 1)
            if len(parts) == 2:
                titre, explication = parts
            else:
                titre, explication = parts[0], ""
            result.append((titre.strip(), explication.strip()))
    return result

def lister_outils_par_attaque(filepath, attaque):
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    # Pattern section attaque
    attaque_regex = r"### ⚡ Attaque.?[: ]+" + re.escape(attaque)
    outils = []
    for match in re.finditer(attaque_regex, contenu, re.IGNORECASE):
        bloc = contenu[match.start():]
        # Trouver l'outil associé
        outil_match = re.search(r"#### Outil.?[: ]+(.+?)\n- \*\*Description", bloc)
        if outil_match:
            nom_outil = outil_match.group(1).strip()
            desc = re.search(r"- \*\*Description\*\*\s*:?(.+)", bloc)
            description = desc.group(1).strip() if desc else ""
            # Recherche installation
            install_match = re.search(r"- \*\*Installation\*\*\s*:?(.+?)(?:\n-|\n####|\n###|$)", bloc, re.DOTALL)
            install_cmds = install_match.group(1).strip() if install_match else "N/A"
            # Recherche commande(s)
            cmds = re.findall(r"- \*\*Commande\*\*\s*:?(.+)", bloc)
            outils.append({
                "outil": nom_outil,
                "description": description,
                "installation": install_cmds,
                "commandes": cmds,
            })
    return outils

def logger_action(actions):
    with open(os.path.join(LOGS_DIR, REPORT_FILE), "a", encoding="utf-8") as f:
        for act in actions:
            f.write(f"- [{act['date']}] Couche: {act['couche']} / Attaque: {act['attaque']}\n")
            f.write(f"  Outil: {act['outil']}\n")
            f.write(f"  Commande exécutée: {act['commande']}\n\n")

def main():
    actions_log = []
    print("==== Pentest Toolkit ====\n")
    couches = lister_couches()
    for idx, (nom, path) in enumerate(couches, 1):
        print(f"{idx}. {nom}")
    choix = input("\nChoisissez la couche à explorer (numéro) : ")
    try:
        couche_idx = int(choix) - 1
        couche_nom, couche_file = couches[couche_idx]
    except (ValueError, IndexError):
        print("Choix invalide.")
        return

    print(f"\n-- Types d'attaques disponibles pour {couche_nom} --")
    attaques = lister_attaques_avec_explications(couche_file)
    for idx, (nom, exp) in enumerate(attaques, 1):
        print(f"{idx}. {nom}  →  {exp}")
    attaque_choix = input("\nSélectionnez une attaque à approfondir (numéro) : ")
    try:
        attaque_idx = int(attaque_choix) - 1
        attaque_nom = attaques[attaque_idx][0]
    except (ValueError, IndexError):
        print("Choix invalide.")
        return

    print(f"\n-- Outils disponibles pour '{attaque_nom}' --")
    outils = lister_outils_par_attaque(couche_file, attaque_nom)
    if not outils:
        print("Aucun outil trouvé pour cette attaque.")
        return
    for idx, outil in enumerate(outils, 1):
        print(f"\n{idx}. {outil['outil']}")
        print(f"   Description : {outil['description']}")
        print(f"   Installation : {outil['installation']}")
        for cmd in outil['commandes']:
            print(f"   Commande d'usage : {cmd}")

    outil_choix = input("\nChoisissez un outil à utiliser (numéro) : ")
    try:
        outil_idx = int(outil_choix) - 1
        outil_sel = outils[outil_idx]
    except (ValueError, IndexError):
        print("Choix invalide.")
        return

    # Installation
    print(f"\n[INFO] Pour installer l'outil si besoin : {outil_sel['installation']}")
    print("\nCommandes à exécuter :")
    for i, cmd in enumerate(outil_sel['commandes'], 1):
        print(f"{i}. {cmd}")

    cmd_choix = input("\nTape le numéro de la commande à exécuter (ou 'q' pour annuler) : ")
    if cmd_choix.lower() == 'q':
        print("Annulé.")
        return

    try:
        cmd_idx = int(cmd_choix) - 1
        cmd_a_exec = outil_sel['commandes'][cmd_idx]
    except (ValueError, IndexError):
        print("Choix invalide.")
        return

    print(f"\n[!] Securité : le script NE lance PAS la commande automatiquement par défaut.")
    print(f"Commande à exécuter manuellement :\n{cmd_a_exec}")

    exec_confirm = input("Veux-tu lancer cette commande depuis le script ? (danger !) [o/n] : ")
    if exec_confirm.lower() == 'o':
        import subprocess
        print("Exécution...")
        try:
            subprocess.run(cmd_a_exec, shell=True, check=True)
        except Exception as e:
            print("Erreur d'exécution :", e)
    else:
        print("Commande non exécutée.")

    # Log
    actions_log.append({
        "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "couche": couche_nom,
        "attaque": attaque_nom,
        "outil": outil_sel['outil'],
        "commande": cmd_a_exec,
    })
    logger_action(actions_log)
    print(f"\n[OK] Rapport mis à jour dans {os.path.join(LOGS_DIR, REPORT_FILE)}")

if __name__ == "__main__":
    main()
