#!/usr/bin/env python3
import os
import re
from datetime import datetime
import shutil

DOCS_DIR = "docs"
LOGS_DIR = "logs"
REPORT_FILE = f"rapport_pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"

if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)

def lister_couches():
    couches = []
    for d in os.listdir(DOCS_DIR):
        couche_path = os.path.join(DOCS_DIR, d)
        if os.path.isdir(couche_path):
            for file in os.listdir(couche_path):
                if file.startswith('cheat-couche_') and file.endswith('.md'):
                    couches.append((d, os.path.join(couche_path, file)))
    couches = sorted(couches, key=lambda x: x[0])
    return couches

def extraire_types_attaques(filepath):
    """ Extrait UNIQUEMENT la liste des attaques (titre + explication) de la section 1. """
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    pattern = r"## 1\. Types d'attaques.*?\n((?:- .+\n)+)"
    match = re.search(pattern, contenu, re.DOTALL)
    attaques = []
    if match:
        bloc = match.group(1)
        for line in bloc.split('\n'):
            if line.startswith('- '):
                # Coupe sur '  :' ou ':' pour séparer titre et explication
                if '  :' in line:
                    titre, explication = line[2:].split('  :', 1)
                    attaques.append((titre.strip(), explication.strip()))
                elif ':' in line:
                    titre, explication = line[2:].split(':', 1)
                    attaques.append((titre.strip(), explication.strip()))
                else:
                    attaques.append((line[2:].strip(), ""))
    return attaques

def extraire_bloc_attaque(filepath, attaque_nom):
    """Récupère le bloc markdown de la section correspondant à l'attaque choisie."""
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    # On cherche le bloc '### ⚡ Attaque : NOM_ATTAQUE' (avec ou sans espace avant/after :) jusqu'au prochain '###' ou '##' ou fin
    pattern = r"### ⚡ Attaque\s*:\s*" + re.escape(attaque_nom) + r"(.*?)(?=^### |^## |\Z)"
    match = re.search(pattern, contenu, re.DOTALL | re.MULTILINE | re.IGNORECASE)
    if match:
        return match.group(1)
    else:
        return ""

def extraire_outils_du_bloc(bloc):
    """Parse le bloc d'une attaque pour trouver tous les outils et leur contenu."""
    outils = []
    outil_pattern = r"#### Outil\s*:\s*(.+?)\n- \*\*Description\*\*\s*:?\s*(.+?)(?:\n- \*\*Installation\*\*\s*:?\s*(.+?))?\n- \*\*Commande\*\*\s*:?\s*(.+?)(?=\n#### Outil|\n### |\n## |\Z)"
    for match in re.finditer(outil_pattern, bloc, re.DOTALL | re.MULTILINE):
        nom = match.group(1).strip()
        description = match.group(2).strip().replace('\n', ' ')
        installation = match.group(3).strip() if match.group(3) else "N/A"
        commande = match.group(4).strip()
        outils.append({
            "nom": nom,
            "description": description,
            "installation": installation,
            "commande": commande
        })
    return outils

def logger_action(action):
    with open(os.path.join(LOGS_DIR, REPORT_FILE), "a", encoding="utf-8") as f:
        f.write(f"- [{action['date']}] Couche: {action['couche']} / Attaque: {action['attaque']}\n")
        f.write(f"  Outil: {action['outil']}\n")
        f.write(f"  Commande exécutée: {action['commande']}\n\n")

def outil_installe(nom):
    """Test rapide si l’outil est dans le PATH (basique, ne gère pas tous les cas)"""
    return shutil.which(nom.split()[0]) is not None

def main():
    print("==== Pentest Toolkit ====\n")
    couches = lister_couches()
    for idx, (nom, path) in enumerate(couches, 1):
        print(f"{idx}. {nom}")
    choix = input("\nChoisissez la couche à explorer (numéro) : ")
    try:
        couche_idx = int(choix) - 1
        couche_nom, couche_file = couches[couche_idx]
    except (ValueError, IndexError):
        print("Choix invalide.")
        return

    # Étape 1 : Affiche les types d'attaques (titre + explication)
    print(f"\n-- Types d'attaques disponibles pour {couche_nom} --")
    attaques = extraire_types_attaques(couche_file)
    if not attaques:
        print("Aucune attaque trouvée dans ce fichier.")
        return
    for idx, (nom, exp) in enumerate(attaques, 1):
        print(f"{idx}. {nom}{'  →  ' + exp if exp else ''}")
    attaque_choix = input("\nSélectionnez une attaque à approfondir (numéro) : ")
    try:
        attaque_idx = int(attaque_choix) - 1
        attaque_nom = attaques[attaque_idx][0]
    except (ValueError, IndexError):
        print("Choix invalide.")
        return

    # Étape 2 : Affiche les outils pour cette attaque
    bloc_attaque = extraire_bloc_attaque(couche_file, attaque_nom)
    outils = extraire_outils_du_bloc(bloc_attaque)
    if not outils:
        print("Aucun outil trouvé pour cette attaque.")
        return
    print(f"\n-- Outils disponibles pour '{attaque_nom}' --")
    for idx, outil in enumerate(outils, 1):
        print(f"{idx}. {outil['nom']} : {outil['description']}")
    outil_choix = input("\nChoisissez un outil à utiliser (numéro) : ")
    try:
        outil_idx = int(outil_choix) - 1
        outil_sel = outils[outil_idx]
    except (ValueError, IndexError):
        print("Choix invalide.")
        return

    # Étape 3 : Vérifie l'installation de l'outil
    outil_name_cli = outil_sel['nom'].split()[0].lower()
    if not outil_installe(outil_name_cli):
        print(f"\n[INFO] L’outil '{outil_sel['nom']}' n'est pas détecté sur le système.")
        print(f"Pour l’installer, lance la commande suivante :\n{outil_sel['installation']}")
        input("Appuie sur Entrée quand l’outil est installé ou prêt à continuer...")
    else:
        print(f"\n[INFO] L’outil '{outil_sel['nom']}' est installé.")

    # Étape 4 : Affiche la commande
    print("\nCommande à exécuter pour cette attaque :")
    print(f"{outil_sel['commande']}")
    exec_confirm = input("\nVeux-tu lancer cette commande depuis le script ? (danger !) [o/n] : ")
    if exec_confirm.lower() == 'o':
        import subprocess
        print("Exécution...")
        try:
            subprocess.run(outil_sel['commande'], shell=True, check=True)
        except Exception as e:
            print("Erreur d'exécution :", e)
    else:
        print("Commande non exécutée.")

    # Log
    action = {
        "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "couche": couche_nom,
        "attaque": attaque_nom,
        "outil": outil_sel['nom'],
        "commande": outil_sel['commande'],
    }
    logger_action(action)
    print(f"\n[OK] Rapport mis à jour dans {os.path.join(LOGS_DIR, REPORT_FILE)}")

if __name__ == "__main__":
    main()
