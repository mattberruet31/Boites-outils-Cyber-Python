#!/usr/bin/env python3
import os
import re
from datetime import datetime
import shutil
import ipaddress

DOCS_DIR = "docs"
LOGS_DIR = "logs"
REPORT_FILE = f"rapport_pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"

if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)

def lister_couches():
    couches = []
    for d in os.listdir(DOCS_DIR):
        couche_path = os.path.join(DOCS_DIR, d)
        if os.path.isdir(couche_path):
            for file in os.listdir(couche_path):
                if file.startswith('cheat-couche_') and file.endswith('.md'):
                    couches.append((d, os.path.join(couche_path, file)))
    couches = sorted(couches, key=lambda x: x[0])
    return couches

def extraire_types_attaques(filepath):
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    pattern = r"## 1\. Types d'attaques.*?\n((?:- .+\n)+)"
    match = re.search(pattern, contenu, re.DOTALL)
    attaques = []
    if match:
        bloc = match.group(1)
        for line in bloc.split('\n'):
            if line.startswith('- '):
                if '  :' in line:
                    titre, explication = line[2:].split('  :', 1)
                    attaques.append((titre.strip(), explication.strip()))
                elif ':' in line:
                    titre, explication = line[2:].split(':', 1)
                    attaques.append((titre.strip(), explication.strip()))
                else:
                    attaques.append((line[2:].strip(), ""))
    return attaques

def extraire_bloc_attaque(filepath, attaque_nom):
    with open(filepath, encoding='utf-8') as f:
        contenu = f.read()
    attaque_pattern = re.compile(
        r"###\s*⚡\s*Attaque\s*:\s*([^\n]+)\n(.*?)(?=^### |^## |\Z)", re.DOTALL | re.MULTILINE | re.IGNORECASE)
    for match in attaque_pattern.finditer(contenu):
        titre = match.group(1).strip().lower()
        if titre == attaque_nom.strip().lower():
            return match.group(2)
    return ""

def extraire_outils_du_bloc(bloc):
    """
    Parse le bloc d'une attaque pour trouver tous les outils, commandes et infos.
    """
    outils = []
    outil_pattern = re.compile(
        r"####\s*Outil\s*:\s*([^\n]+)\n"
        r"\*\*Description\*\*\s*:\s*(.+?)\n"
        r"\*\*Installation\*\*\s*:\s*(.+?)(?=\n\*\*Commande\*\*|\n\*\*Info\*\*|\n\*\*Note\*\*|\n#### Outil|$)",
        re.DOTALL | re.MULTILINE
    )
    for outil_match in outil_pattern.finditer(bloc):
        nom = outil_match.group(1).strip()
        description = outil_match.group(2).strip().replace('\n', ' ')
        installation = outil_match.group(3).strip()
        commandes = []
        infos = []
        outil_bloc_start = outil_match.end()
        outil_bloc_end = bloc.find('#### Outil', outil_bloc_start)
        outil_bloc = bloc[outil_bloc_start:outil_bloc_end if outil_bloc_end != -1 else None]
        for cmd_match in re.finditer(r"\*\*Commande\*\*\s*:\s*(.+)", outil_bloc or ''):
            cmd = cmd_match.group(1).strip()
            commandes.append(cmd)
        for info_match in re.finditer(r"\*\*(Info|Note)\*\*\s*:\s*(.+)", outil_bloc or ''):
            infos.append(info_match.group(2).strip())
        if not commandes:
            commandes = ["(Aucune commande shell définie pour cet outil)"]
        outils.append({
            "nom": nom,
            "description": description,
            "installation": installation,
            "commandes": commandes,
            "infos": infos
        })
    return outils

def is_ip_param(param):
    return 'ip' in param.lower()

def parametrize_command(cmd):
    params = re.findall(r"\[([^\]|]+)(?:\|([^\]]+))?\]", cmd)
    values = {}
    for param, default in params:
        prompt = f"Entrez la valeur pour '{param.strip()}'"
        if default:
            prompt += f" (Entrée pour '{default.strip()}')"
        prompt += " : "
        while True:
            value = input(prompt).strip()
            if not value and default:
                value = default.strip()
            if is_ip_param(param) and value:
                try:
                    ipaddress.ip_address(value)
                    break
                except Exception:
                    print("⛔ Valeur invalide, merci d’entrer une IP valide.")
            else:
                break
        values[param] = value
    for k, v in values.items():
        cmd = re.sub(rf"\[{re.escape(k)}(\|[^\]]+)?\]", v, cmd)
    return cmd, values

def logger_action(action):
    with open(os.path.join(LOGS_DIR, REPORT_FILE), "a", encoding="utf-8") as f:
        f.write(f"- [{action['date']}] Couche: {action['couche']} / Attaque: {action['attaque']}\n")
        f.write(f"  Outil: {action['outil']}\n")
        if action.get("cmd_params"):
            f.write(f"  Paramètres : {action['cmd_params']}\n")
        f.write(f"  Commande exécutée: {action['commande']}\n\n")

def outil_installe(nom):
    return shutil.which(nom.split()[0]) is not None

def choisir_dans_menu(items, titre="Faites un choix :", peut_annuler=True):
    while True:
        print("\n" + titre)
        for idx, item in enumerate(items, 1):
            print(f"{idx}. {item}")
        if peut_annuler:
            print("q. Annuler/Retour")
        choix = input("Votre choix : ")
        if peut_annuler and choix.lower() == 'q':
            return None
        try:
            choix_idx = int(choix) - 1
            if 0 <= choix_idx < len(items):
                return choix_idx
        except ValueError:
            pass
        print("Choix invalide.")

def main():
    print("==== Pentest Toolkit (v3) ====\n")
    couches = lister_couches()
    couche_idx = choisir_dans_menu([c[0] for c in couches], "Choisissez la couche à explorer :")
    if couche_idx is None:
        print("Abandon.")
        return
    couche_nom, couche_file = couches[couche_idx]

    attaques = extraire_types_attaques(couche_file)
    if not attaques:
        print("Aucune attaque trouvée dans ce fichier.")
        return
    attaque_idx = choisir_dans_menu([f"{a[0]}  →  {a[1]}" for a in attaques], f"-- Types d'attaques disponibles pour {couche_nom} --")
    if attaque_idx is None:
        print("Retour menu principal.")
        return
    attaque_nom = attaques[attaque_idx][0]

    bloc_attaque = extraire_bloc_attaque(couche_file, attaque_nom)
    outils = extraire_outils_du_bloc(bloc_attaque)
    if not outils:
        print("Aucun outil trouvé pour cette attaque.")
        return

    outil_idx = choisir_dans_menu([f"{o['nom']} : {o['description']}" for o in outils], f"-- Outils disponibles pour '{attaque_nom}' --")
    if outil_idx is None:
        print("Retour au choix de l'attaque.")
        return
    outil_sel = outils[outil_idx]

    # Vérifie installation
    outil_name_cli = outil_sel['nom'].split()[0].lower()
    if not outil_installe(outil_name_cli):
        print(f"\n[INFO] L’outil '{outil_sel['nom']}' n'est pas détecté sur le système.")
        print(f"Pour l’installer, lance la commande suivante :\n{outil_sel['installation']}")
        input("Appuie sur Entrée quand l’outil est installé ou prêt à continuer...")
    else:
        print(f"\n[INFO] L’outil '{outil_sel['nom']}' est installé.")

    # Multi-commandes support
    while True:
        cmd_idx = choisir_dans_menu(outil_sel['commandes'], "Commandes disponibles pour cette attaque :", False)
        if cmd_idx is None:
            print("Retour au choix de l'outil.")
            return
        cmd_original = outil_sel['commandes'][cmd_idx]
        cmd_ready, cmd_params = parametrize_command(cmd_original)
        print("\nCommande finale à exécuter :")
        print(cmd_ready)
        exec_confirm = input("\nVeux-tu lancer cette commande depuis le script ? (danger !) [o/n/r pour revenir] : ")
        if exec_confirm.lower() == 'o':
            import subprocess
            print("Exécution...")
            try:
                subprocess.run(cmd_ready, shell=True, check=True)
            except Exception as e:
                print("Erreur d'exécution :", e)
            # Log avec paramètres
            action = {
                "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "couche": couche_nom,
                "attaque": attaque_nom,
                "outil": outil_sel['nom'],
                "commande": cmd_ready,
                "cmd_params": cmd_params
            }
            logger_action(action)
            print(f"\n[OK] Rapport mis à jour dans {os.path.join(LOGS_DIR, REPORT_FILE)}")
            # Affiche les infos complémentaires s’il y en a
            if outil_sel.get('infos'):
                print("\nInfos complémentaires :")
                for info in outil_sel['infos']:
                    print(f"- {info}")
            break
        elif exec_confirm.lower() == 'r':
            continue
        else:
            print("Commande non exécutée.")
            break

if __name__ == "__main__":
    main()
